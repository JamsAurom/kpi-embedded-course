=================================================
**Лабораторная работа №2 Связный список и потоки ядра**
=================================================

Тема: Принципы работы со списками в ядре, потоки и механизмы синхронизации
---------------------------------

Цель: Научиться синхронизировать потоки в Linux
------------------------------------

Структура директории
-------------------------------------------
+-------------------+----------------------------------+ 
| Папка и файлы     |            Описание              |
+===================+==================================+ 
|        src        | Исходный код лабораторной работы |
+-------------------+----------------------------------+ 
|       Makefile    |     Файл для компиляции проекта  | 
+-------------------+----------------------------------+ 
|       README.rst  | Отчет о лабораторной работе      |
+-------------------+----------------------------------+

**Оглавление:**
----------------

      #. `Задание`_
      #. `Ход работы`_  
              #. `В проекте используються библиотеки`_
              #. `Разберем код`_
              #. `В проекте используються библиотеки`_


**Задание**
~~~~
* содержит переменную
* запускает M потоков на одновременное выполнение
* каждый поток инкрементирует переменную N раз, кладет значение переменной в список и завершается
* при выгрузке модуль выводит значение переменной и содержимое списка
* использовать параметры модуля для задания инкремента N и количества потоков M (в коде параметры должны называться осмысленно)
* для переменной, списка, потоков использовать динамическую аллокацию. Переменную передавать в поток по ссылке аргументом

**Ход работы**
-----------

В проекте используються библиотеки
~~~~
* ``<linux/module.h>`` требуется для всех модулей
* ``<linux/kernel.h>`` требуется для системной информации
* ``<linux/init.h>`` используется для инициализации и закрытия модуля
* ``<linux/list.h>`` для создания списков
* ``<linux/interrupt.h>`` используется для задач
* ``<linux/slab.h>`` для более эффективного управления памятью
* ``<linux/kthread.h>`` для взаимодействия с потоками данных
* ``<asm/atomic.h>`` для атомарных операций (операция, которая либо выполняется целиком, либо не выполняется вовсе; операция, которая не может быть частично выполнена и частично не выполнена.)

В модуле должны быть основные разделы, такие как:

* инициализация
* выход

В нашем случае все основные операции будут проходить в инициализации. Объявление перемнных, запуск N потоков. Запуск этих же потоков. 
В функции выхода будет вывод данных (списка) в терминал и освобождение памяти.
Функция потока, будет только итерировать данные переменную и все.
Так же понадобяться функции блокирования ядра ``static void lock(atomic_t *arg)`` и его разблокирование 
``static void unlock(atomic_t *arg)`` это достаточно простые функции, расмотрим их далее. 

**Разберем код**
~~~~~~~~~~~~~~~~~~

**Переменные**
""""""""""""""""""""""""""""""""""""
* ``iterator`` входной параметр, который определяет на сколько итерировать значение.
* ``kernel_quantity`` количество потоков которое надо будет создать для выполнения итерирования.

К переменным вернемся далее, а пока **ввод параметров**

.. code-block:: C

   module_param(iterator, int, 0);
   MODULE_PARM_DESC(iterator, "How much to iterate the variable?");

В ``module_param`` мы должны передать переменную, тип данных и права доступа(таблица будет приведена ниже `Три варианта записи прав пользователя`_)

``MODULE_PARM_DESC`` испльзуется при вызове ``modinfo`` для вывода более подробной информации о модуле.

Объявление структуры
""""""""""""""""""""""""""""""""""""

Структура ``list_rez`` нужна для вывода данных. В ней воспользуемся библиотекой ``<linux/list.h>`` из нее берем ``struct list_head`` эта структура
поможет объявить голову и конец списка, так же будет хронить ссылку на предыдущий и следующий эллемент.

.. code-block:: C

    struct list_rez {
      int rez;
      struct list_head m_list;
    };
    
Далее описываем создание глобальных списков:
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

.. code-block:: C

  LIST_HEAD(out_list);
  struct list_rez *out_list_acc;
  


Три варианта записи прав пользователя
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

+------------------------+--------------------------+------------------------+--------------------------+----------------------------+
| двоичная               | восьмеричная             | символьная             | права на файл            | права на каталог           |
+------------------------+--------------------------+------------------------+--------------------------+----------------------------+
| 000                    | 0                        | ---                    | нет                      | нет                        |
+------------------------+--------------------------+------------------------+--------------------------+----------------------------+
| 001                    | 1                        | --x                    | выполнение               | чтение файлов и их свойств |
+------------------------+--------------------------+------------------------+--------------------------+----------------------------+
| 010                    | 2                        | -w-                    | запись                   | нет                        |
+------------------------+--------------------------+------------------------+--------------------------+----------------------------+
| 011                    | 3                        | -wx                    | запись и выполнение      | всё, 001                   |
+------------------------+--------------------------+------------------------+--------------------------+----------------------------+
| 100                    | 4                        | r--                    | чтение                   | чтение имён файлов         |
+------------------------+--------------------------+------------------------+--------------------------+----------------------------+
| 101                    | 5                        | r-x                    | чтение и выполнение      | доступ на чтение           |
+------------------------+--------------------------+------------------------+--------------------------+----------------------------+
| 110                    | 6                        | rw-                    | чтение и запись          | чтение имён файлов         |
+------------------------+--------------------------+------------------------+--------------------------+----------------------------+
| 111                    | 7                        | rwx                    | все права                | все права                  |
+------------------------+--------------------------+------------------------+--------------------------+----------------------------+

``printk`` используется для вывода информации в консоль, имеет макросы:
~~~~
* ``KERN_EMERG`` - Система не используется
* ``KERN_ALERT`` - Действие должно быть принято немедленно
* ``KERN_CRIT`` - Критические условия
* ``KERN_ERR`` - Условия ошибки
* ``KERN_WARNING`` - Условия предупреждения
* ``KERN_NOTICE`` - Нормальное, но значимое состояние
* ``KERN_INFO`` - информационный
* ``KERN_DEBUG`` - Сообщения уровня отладки

Мы использывали ``KERN_INFO``

``DECLARE_TASKLET`` - используется для объявления тасклита, передаем функцию ``tasklet_handler``, первый параметр - имя, третий параметр - параметры переданные в функцию, в нашем случае ``NULL``.

``__init firstmod_init`` - инициализация тасклита.

``__exit firstmod_exit`` - закрытие тасклита.

``tasklet_schedule`` - вызываем в инициализации для того, что бы нечего не мешало системе при выполенении задачи, тасклита.

``tasklet_kill`` - убивает задачу(тасклит).

Мы сохраняем ввод имени пользователя ``static char * user = "$ username"``. Установить ``user = <name>`` в терминале ``module_param (user, charp, S_IRUGO)``.

Сборка и тестирование модуля 
---------------------------
Для сборки, в которой этот модуль использует ``make`` (для следующих команд требуется **root-доступ**). Для вставки используйте ``insmod <имя_модуля>``. Для удаления используйте ``rmmod <имя_модуля>``. Для отображения журнала ядра используйте ``dmesg -k``.

Вывод
----

Был собран и проверен модуль ядра. Убедились в его выполнении. Изменение jiffies не наблюдалось, так как задача выполнялась очень быстро и мы не папали на переключение счетчика.




