=================================================
**Лабораторная работа №4 Символьное устройство**
=================================================

**Тема**: *Создание собственного драйвера*

**Цель**: *Научиться работать с драйверами(функции ввода, вывода, чтение файла) в Linux*

Структура директории
-------------------------------------------
+-------------------+----------------------------------+ 
| Папка и файлы     |            Описание              |
+===================+==================================+ 
|        src        | Исходный код лабораторной работы |
+-------------------+----------------------------------+
|  src/hivemod.c    | Исходный код модуля              |
+-------------------+----------------------------------+
|  src/ioctl.h      | Библиотека для модуля и проверки |
+-------------------+----------------------------------+
|  src/Makefile     | Файл для компиляции проверки     |
+-------------------+----------------------------------+
|  src/user.c       | Исходный код функции проверки    |
+-------------------+----------------------------------+
|       Makefile    |     Файл для компиляции модуля   | 
+-------------------+----------------------------------+ 
|       README.rst  | Отчет о лабораторной работе      |
+-------------------+----------------------------------+

**Оглавление:**
----------------

      #. `Задание`_
      #. `Теория`_ 
      #. `Ход работы`_  
              #. `В проекте используються библиотеки`_
              #. `Так же нам понадобяться переменные`_
              #. `Рассмотрим функции`_ 
                        #. `Функция таймера`_
                        #. `Функция отложенного действия`_
                        #. `Печать структуры`_
                        #. `Удаление структуры`_
                        #. `Функция для первого потока`_
                        #. `Функция для второго потока`_
                        #. `Инициализации`_
                        #. `Выход`_
      #. `Сборка и тестирование модуля`_
      #. `Вывод`_


**Задание**
--------------

Препадователем был выдан модуль, в котором надо было внести определенные фиксы в код, так же дописать некоторые функции и оптимизировать код. Функции, такие как: ``ioctl``. 

**Теория**
--------------

**Регистрация** драйверов в системе происходит спомощью пары номеров: ``major``, ``minor``. Но так же надо связать номер устройства с его имеем, по сути это сказать модулю: если что то обращается по этому имени, то это твоя работа, делай ее. Сейчас имена номера выделяються динамически, ранее было не так. С ядра 2.4, за один ``major`` отвечал один модуль. Потом, с ядра 2.6 у каждого ``major`` могло быть 2 модуля (делилось попалам 1 - [0-63], 2 - [64-127]) А сейчас динамическое выделение.

**file_operations** - содержит указатели на функции драйвера, которые отвечают за выполнение различных операцийс утройством. (по сути вся работа с ``/dev`` реализована через эту структуру)

**Ход работы**
-----------

**Модуль ядра**
~~~~~~~~~~~~~~~~~~

**В проекте используються библиотеки**
~~~~~~~~~~~~~~~~~~

* ``<linux/module.h>`` требуется для всех модулей
* ``<linux/kernel.h>`` требуется для системной информации
* ``<linux/init.h>`` используется для инициализации и закрытия модуля
* ``<linux/list.h>`` для создания списков
* ``<linux/jiffies.h>`` количество импульсов системного таймера
* ``<linux/fs.h>`` содержит структуру file_operations подробнее в теории
* ``<linux/errno.h>`` коды ошибок
* ``<linux/slab.h>``
* ``<linux/cdev.h>`` автоматически выделяет старший номер и связывает с младшим
* ``<linux/uaccess.h>`` API помогает обмениваться данными
* ``<linux/miscdevice.h>`` помогает выбрать номер и зарегестрировать устройство

**Рассмотрим структуры**
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

``alloc_status`` - битовое поле, хранит флаги выделения ресурсов

Рассмотрим данные которые хранит структура

* ``dev_created`` - устройство пользователя было успешно создано
* ``cdev_added`` - адрес устройства

``hive_file_item`` - stores data for each descriptor

Рассмотрим данные которые хранит структура

* ``buffer`` память, которую мы выделяем для каждого файла
* ``length`` размер буфера
* ``rdoffset`` смещение чтения
* ``wroffset`` смещение записи

``hive_flist_item`` - учет открытых дескрипторов

Рассмотрим данные которые хранит структура

* ``list`` поля для связывания списка
* ``file`` создается в ``open()``, удаляется при изменениях ``close()`` во время файловых операций, но ptr остается прежним

**Рассмотрим переменные глобальные**
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

``hive_flist`` - список 

**Рассмотрим функции**
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

**Функция создания эллемента списка с буфером**
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Имя функции ``hive_flist_new`` она inline.

Принимает значения типа: ``unsigned long buffer_size``

Возвращает данные типа: ``struct hive_flist_item *``

По сути функция просто выделяет память типа ``struct hive_flist_item *`` эллементу и возвращает его.
Так же есть проверка на корректность выделения памяти.

**Функция удаления эллемента списка с буфером**
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Имя функции ``hive_flist_rm`` она inline.

Принимает значения типа: ``struct hive_flist_item``

Возвращает данные типа: ``void``

Функция проверяет, если такой эллемент существует, то удаляем его из списка и чистим память, если нет, то выходим из функции.

**Функция поиска в списке**
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Имя функции ``hive_flist_get``

Принимает значения типа: ``struct file``

Возвращает данные типа: ``int``

Функция линейно по списку ищет нужное значение (входное), если находит то возвращает номер єтого єллемента, а если нет то ``NULL``. Поиск реализован линейно.

**Операция открытия**
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Имя функции ``cdev_open``

Принимает значения типа: ``struct inode *``, ``struct file *``

Возвращает данные типа: ``int``

Функция линейно по списку ищет нужное значение (входное), если находит то возвращает номер єтого єллемента, а если нет то ``NULL``. Поиск реализован линейно.

















