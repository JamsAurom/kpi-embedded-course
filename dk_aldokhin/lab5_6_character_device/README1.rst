=================================================
**Лабораторная работа №4 Символьное устройство**
=================================================

**Тема**: *Создание собственного драйвера*

**Цель**: *Научиться работать с драйверами(функции ввода, вывода, чтение файла) в Linux*

Структура директории
-------------------------------------------
+-------------------+----------------------------------+ 
| Папка и файлы     |            Описание              |
+===================+==================================+ 
|        src        | Исходный код лабораторной работы |
+-------------------+----------------------------------+
|  src/hivemod.c    | Исходный код модуля              |
+-------------------+----------------------------------+
|  src/ioctl.h      | Библиотека для модуля и проверки |
+-------------------+----------------------------------+
|  src/Makefile     | Файл для компиляции проверки     |
+-------------------+----------------------------------+
|  src/user.c       | Исходный код функции проверки    |
+-------------------+----------------------------------+
|       Makefile    |     Файл для компиляции модуля   | 
+-------------------+----------------------------------+ 
|       README.rst  | Отчет о лабораторной работе      |
+-------------------+----------------------------------+

**Оглавление:**
----------------

      #. `Задание`_
      #. `Теория`_ 
      #. `Ход работы`_  
              #. `В проекте используються библиотеки`_
              #. `Так же нам понадобяться переменные`_
              #. `Рассмотрим функции`_ 
                        #. `Функция таймера`_
                        #. `Функция отложенного действия`_
                        #. `Печать структуры`_
                        #. `Удаление структуры`_
                        #. `Функция для первого потока`_
                        #. `Функция для второго потока`_
                        #. `Инициализации`_
                        #. `Выход`_
      #. `Сборка и тестирование модуля`_
      #. `Вывод`_


**Задание**
--------------

Препадователем был выдан модуль, в котором надо было внести определенные фиксы в код, так же дописать некоторые функции и оптимизировать код. Функции, такие как: ``ioctl``. 

**Теория**
--------------

**Регистрация** драйверов в системе происходит спомощью пары номеров: ``major``, ``minor``. Но так же надо связать номер устройства с его имеем, по сути это сказать модулю: если что то обращается по этому имени, то это твоя работа, делай ее. Сейчас имена номера выделяються динамически, ранее было не так. С ядра 2.4, за один ``major`` отвечал один модуль. Потом, с ядра 2.6 у каждого ``major`` могло быть 2 модуля (делилось попалам 1 - [0-63], 2 - [64-127]) А сейчас динамическое выделение.

**file_operations** - содержит указатели на функции драйвера, которые отвечают за выполнение различных операцийс утройством. (по сути вся работа с ``/dev`` реализована через эту структуру)

**Ход работы**
-----------

**Модуль ядра**
""""""""""""""""

**В проекте используються библиотеки**
~~~~~~~~~~~~~~~~~~

* ``<linux/module.h>`` требуется для всех модулей
* ``<linux/kernel.h>`` требуется для системной информации
* ``<linux/init.h>`` используется для инициализации и закрытия модуля
* ``<linux/list.h>`` для создания списков
* ``<linux/jiffies.h>`` количество импульсов системного таймера
* ``<linux/fs.h>`` содержит структуру file_operations подробнее в теории
* ``<linux/errno.h>`` коды ошибок
* ``<linux/slab.h>``
* ``<linux/cdev.h>`` автоматически выделяет старший номер и связывает с младшим
* ``<linux/uaccess.h>`` API помогает обмениваться данными
* ``<linux/miscdevice.h>`` помогает выбрать номер и зарегестрировать устройство

**Рассмотрим структуры**
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

``alloc_status`` - битовое поле, хранит флаги выделения ресурсов

Рассмотрим данные которые хранит структура

* ``dev_created`` - устройство пользователя было успешно создано
* ``cdev_added`` - адрес устройства

``hive_file_item`` - stores data for each descriptor

Рассмотрим данные которые хранит структура

* ``buffer`` память, которую мы выделяем для каждого файла
* ``length`` размер буфера
* ``rdoffset`` смещение чтения
* ``wroffset`` смещение записи

``hive_flist_item`` - учет открытых дескрипторов

Рассмотрим данные которые хранит структура

* ``list`` поля для связывания списка
* ``file`` создается в ``open()``, удаляется при изменениях ``close()`` во время файловых операций, но ptr остается прежним

**Рассмотрим переменные глобальные**
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

``hive_flist`` - список 

**Рассмотрим функции**
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

**Функция создания эллемента списка с буфером**
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Имя функции ``hive_flist_new`` она inline.

Принимает значения типа: ``unsigned long buffer_size``

Возвращает данные типа: ``struct hive_flist_item *``

По сути функция просто выделяет память типа ``struct hive_flist_item *`` эллементу и возвращает его.
Так же есть проверка на корректность выделения памяти.

**Функция удаления эллемента списка с буфером**
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Имя функции ``hive_flist_rm`` она inline.

Принимает значения типа: ``struct hive_flist_item``

Возвращает данные типа: ``void``

Функция проверяет, если такой эллемент существует, то удаляем его из списка и чистим память, если нет, то выходим из функции.

**Функция поиска в списке**
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Имя функции ``hive_flist_get``

Принимает значения типа: ``struct file``

Возвращает данные типа: ``int``

Функция линейно по списку ищет нужное значение (входное), если находит то возвращает номер єтого єллемента, а если нет то ``NULL``. Поиск реализован линейно.

**Операция открытия**
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Имя функции ``cdev_open``

Принимает значения типа: ``struct inode *``, ``struct file *``

Возвращает данные типа: ``int``

Создаем два эллемета, двух разных структур: ``hive_file_item *``, ``hive_flist_item *``. Это нужна для определения девайса, создание буфера, чтения и записи. Нужна для работы с девайсом, что бы его инициализировать.

**Операция закрития**
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Имя функции ``cdev_release``

Принимает значения типа: ``struct inode *``, ``struct file *``

Возвращает данные типа: ``int``

Операция нужна для закрытия устройства. Удаляем и освобождаем эллемент типа ``hive_file_item *`` то же самое делаем с ``hive_flist_item *``.

**Операция чтения**
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Имя функции ``cdev_read``

Принимает значения типа: ``struct file *``, ``char __user *``, ``size_t``, ``loff_t *``

Возвращает данные типа: ``ssize_t``

Функция чтения файла, именно его и размер буфера принимает функция так же еще запрос для чтения в буфер и позицию начала чтения. 

**Операция записи**
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Имя функции ``cdev_write``

Принимает значения типа: ``struct file *``, ``char __user *``, ``size_t``, ``loff_t *``

Возвращает данные типа: ``ssize_t``

Функция записи файла, пишет данные определенного размера в файл. Так же надо не забыть добавить ``\0`` для конца файла.

**Операция двусторонняя функция ioctl**
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Имя функции ``cdev_ioctl``

Принимает значения типа: ``struct file *``, ``unsigned int``, ``unsigned long``

Возвращает данные типа: ``long``

Принимает данные: файл, команда и параметр.

**Очень важная штука**
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

      .. code-block:: C
      
      static struct file_operations hive_fops = {
      	.open =           &cdev_open,
      	.release =        &cdev_release,
      	.read =           &cdev_read,
      	.write =          &cdev_write,
      	.unlocked_ioctl = &cdev_ioctl,
      	// required to prevent module unloading while fops are in use
      	.owner =          THIS_MODULE,
      };

Тут мы говорим какая функция, которую вызывает пользователь, выполняется в модуле. По сути это инерпритатор имен, скажем так.

**Операция очистки модуля**
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Имя функции ``module_cleanup``

Принимает значения типа: ``void``

Возвращает данные типа: ``void``

Память освобождаем в обратном порядке, все как всегда. Это освобождение при выгрузке модуля ядра.

Дальше идут функции инициализации и закрытия.

**Операция инициализации**
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Имя функции ``cdevmod_init``

Принимает значения типа: ``void``

Возвращает данные типа: ``int``

В начале надо проверить, ввели мы параметр или нет, если нет, то создаем с тем номером, что выбрали. Дальше идут проверки, 

**Пользовательская функция**
""""""""""""""""""""""""""""""""

**В проекте используються библиотеки**
~~~~~~~~~~~~~~~~~~

* ``<fcntl.h>`` параметры управления файлами
* ``<stdio.h>`` Полезные функции, по типу printf(), scanf()
* ``<stdlib.h>`` функции выделения памяти и все в этом духе, стандартная либа
* ``<string.h>`` стандартная библиотека, текстового типа
* ``<sys/ioctl.h>`` для взаимодействия с пользователем, внешними входами и выходами

Так же понадобиться собственная библиотека ``"ioctl.h"`` для буфера.

**Рассмотрим переменные глобальные**
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

``dev`` - имя для адресации к модулю 

**Рассмотрим функции**
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

**Функция подготовки**
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Имя функции ``prepare``

Принимает значения типа: ``char *``

Возвращает данные типа: ``int``

Функция должна обратиться к модулю, что бы индефицироать себя. Далее запишим данные, те которые мы ввели в модуле.

**Функция тестирования**
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Имя функции ``test``

Принимает значения типа: ``int``

Возвращает данные типа: ``void``

Эта функция тестирует наши наработки. Далее создаем переменную длиной нашего буфера (она объявлена дефайном в шопке). После чего мы считываем данные. 

**Основная функция**
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Имя функции ``main``

Принимает значения типа: ``int``, ``char *``

Возвращает данные типа: ``int``

Открывает два устройства, а потом тестирует каждое из них, после чего мы так же мы считываем фразу из модуля, которая там была объявлена и все закрываем.




















